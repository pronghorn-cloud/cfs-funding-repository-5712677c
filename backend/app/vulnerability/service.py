"""SVI service - orchestrates scoring queries and calculations."""

import time
import uuid
from collections import defaultdict
from datetime import datetime

import structlog
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.common.metrics import svi_recalculation_duration_seconds
from app.vulnerability.engine import (
    CategoryWeight,
    IndicatorData,
    RegionScore,
    calculate_region_scores,
    normalize_values,
)
from app.vulnerability.enums import NormalizationMethod
from app.vulnerability.models import (
    DataSource,
    Indicator,
    IndicatorCategory,
    IndicatorValue,
    SVIScore,
)
from app.vulnerability.schemas import (
    HeatmapDataPoint,
    HeatmapResponse,
    IndicatorCategoryResponse,
    IndicatorResponse,
    RecalculateResponse,
    SVIScoreResponse,
)
from app.exceptions import NotFoundException

logger = structlog.get_logger()


async def get_svi_scores(
    db: AsyncSession,
    year: int | None = None,
    region_id: uuid.UUID | None = None,
) -> list[SVIScoreResponse]:
    stmt = select(SVIScore)
    if year:
        stmt = stmt.where(SVIScore.year == year)
    if region_id:
        stmt = stmt.where(SVIScore.region_id == region_id)
    stmt = stmt.order_by(SVIScore.composite_score.desc())

    result = await db.execute(stmt)
    return [SVIScoreResponse.model_validate(s) for s in result.scalars().all()]


async def get_heatmap_data(db: AsyncSession, year: int) -> HeatmapResponse:
    from app.geography.models import Region

    stmt = (
        select(SVIScore, Region)
        .join(Region, SVIScore.region_id == Region.id)
        .where(SVIScore.year == year)
    )
    result = await db.execute(stmt)

    data_points = []
    for score, region in result.all():
        data_points.append(
            HeatmapDataPoint(
                region_id=region.id,
                region_name=region.name,
                latitude=region.latitude,
                longitude=region.longitude,
                composite_score=score.composite_score,
                grade=score.grade,
                category_scores=score.category_scores,
            )
        )

    return HeatmapResponse(year=year, data=data_points)


async def compare_regions(
    db: AsyncSession,
    region_ids: list[uuid.UUID],
    year: int,
) -> list[SVIScoreResponse]:
    stmt = (
        select(SVIScore)
        .where(SVIScore.region_id.in_(region_ids), SVIScore.year == year)
        .order_by(SVIScore.composite_score.desc())
    )
    result = await db.execute(stmt)
    return [SVIScoreResponse.model_validate(s) for s in result.scalars().all()]


async def list_categories(db: AsyncSession) -> list[IndicatorCategoryResponse]:
    stmt = select(IndicatorCategory).order_by(IndicatorCategory.sort_order)
    result = await db.execute(stmt)
    categories = result.scalars().all()
    return [
        IndicatorCategoryResponse(
            **{k: v for k, v in cat.__dict__.items() if not k.startswith("_")},
            indicator_count=len(cat.indicators),
        )
        for cat in categories
    ]


async def list_indicators(
    db: AsyncSession,
    category_id: uuid.UUID | None = None,
    active_only: bool = True,
) -> list[IndicatorResponse]:
    stmt = select(Indicator)
    if category_id:
        stmt = stmt.where(Indicator.category_id == category_id)
    if active_only:
        stmt = stmt.where(Indicator.is_active.is_(True))
    stmt = stmt.order_by(Indicator.sort_order)

    result = await db.execute(stmt)
    return [IndicatorResponse.model_validate(i) for i in result.scalars().all()]


async def recalculate_scores(
    db: AsyncSession,
    year: int,
    normalization_method: str = "min_max",
    region_ids: list[uuid.UUID] | None = None,
) -> RecalculateResponse:
    start_time = time.perf_counter()

    method = NormalizationMethod(normalization_method)

    # Load categories and their weights
    cat_stmt = select(IndicatorCategory).order_by(IndicatorCategory.sort_order)
    cat_result = await db.execute(cat_stmt)
    categories = list(cat_result.scalars().all())
    category_weights = [
        CategoryWeight(name=c.name, weight=float(c.weight)) for c in categories
    ]

    # Load all active indicators grouped by category
    ind_stmt = select(Indicator).where(Indicator.is_active.is_(True))
    ind_result = await db.execute(ind_stmt)
    all_indicators = list(ind_result.scalars().all())

    category_map = {c.id: c.name for c in categories}
    indicators_by_category: dict[str, list[Indicator]] = defaultdict(list)
    for ind in all_indicators:
        cat_name = category_map.get(ind.category_id, "unknown")
        indicators_by_category[cat_name].append(ind)

    # Load indicator values for the year
    val_stmt = select(IndicatorValue).where(IndicatorValue.year == year)
    if region_ids:
        val_stmt = val_stmt.where(IndicatorValue.region_id.in_(region_ids))
    val_result = await db.execute(val_stmt)
    all_values = list(val_result.scalars().all())

    # Group values by indicator for normalization
    values_by_indicator: dict[uuid.UUID, list[IndicatorValue]] = defaultdict(list)
    for val in all_values:
        values_by_indicator[val.indicator_id].append(val)

    # Normalize each indicator's values across regions
    indicator_lookup = {ind.id: ind for ind in all_indicators}
    normalized: dict[uuid.UUID, dict[str, float]] = defaultdict(dict)  # region_id -> {indicator_id: norm_val}

    for ind_id, vals in values_by_indicator.items():
        ind = indicator_lookup.get(ind_id)
        if not ind:
            continue
        raw_values = [v.value for v in vals]
        norm_values = normalize_values(raw_values, method, ind.is_inverse)

        for val, norm_val in zip(vals, norm_values):
            normalized[val.region_id][str(ind_id)] = norm_val
            val.normalized_value = norm_val

    # Calculate scores per region
    regions_calculated = 0
    for region_id, norm_vals in normalized.items():
        ind_data_by_cat: dict[str, list[IndicatorData]] = defaultdict(list)
        for cat_name, inds in indicators_by_category.items():
            for ind in inds:
                if str(ind.id) in norm_vals:
                    ind_data_by_cat[cat_name].append(
                        IndicatorData(
                            indicator_id=str(ind.id),
                            indicator_name=ind.name,
                            category=cat_name,
                            value=norm_vals[str(ind.id)],
                            weight=float(ind.weight),
                            is_inverse=ind.is_inverse,
                        )
                    )

        region_score = calculate_region_scores(
            str(region_id), ind_data_by_cat, norm_vals, category_weights
        )

        # Upsert SVIScore
        existing_stmt = select(SVIScore).where(
            SVIScore.region_id == region_id, SVIScore.year == year
        )
        existing_result = await db.execute(existing_stmt)
        existing = existing_result.scalar_one_or_none()

        if existing:
            existing.composite_score = region_score.composite_score
            existing.grade = region_score.grade
            existing.category_scores = region_score.category_scores
            existing.normalization_method = normalization_method
        else:
            svi = SVIScore(
                region_id=region_id,
                year=year,
                composite_score=region_score.composite_score,
                grade=region_score.grade,
                category_scores=region_score.category_scores,
                normalization_method=normalization_method,
            )
            db.add(svi)

        regions_calculated += 1

    duration = time.perf_counter() - start_time
    svi_recalculation_duration_seconds.observe(duration)

    await logger.ainfo(
        "svi_recalculation_complete",
        year=year,
        regions=regions_calculated,
        duration_seconds=round(duration, 3),
    )

    return RecalculateResponse(
        regions_calculated=regions_calculated,
        duration_seconds=round(duration, 3),
        year=year,
    )
