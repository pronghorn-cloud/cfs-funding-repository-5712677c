"""SVI Scoring Engine - Pure computation functions.

Handles normalization, weighting, composite scoring, and KPMG grading.
All functions are pure (no DB access) for testability.
"""

import math
from dataclasses import dataclass
from decimal import Decimal

from app.vulnerability.enums import KPMGGrade, NormalizationMethod


@dataclass
class IndicatorData:
    indicator_id: str
    indicator_name: str
    category: str
    value: float
    weight: float
    is_inverse: bool


@dataclass
class CategoryWeight:
    name: str
    weight: float


@dataclass
class RegionScore:
    region_id: str
    composite_score: float
    grade: str
    category_scores: dict[str, float]
    risk_index: float | None = None


def normalize_values(
    values: list[float],
    method: NormalizationMethod = NormalizationMethod.MIN_MAX,
    is_inverse: bool = False,
) -> list[float]:
    """Normalize a list of values to 0-100 scale."""
    if not values:
        return []

    if method == NormalizationMethod.MIN_MAX:
        return _normalize_min_max(values, is_inverse)
    elif method == NormalizationMethod.Z_SCORE:
        return _normalize_z_score(values, is_inverse)
    elif method == NormalizationMethod.PERCENTILE:
        return _normalize_percentile(values, is_inverse)
    else:
        return _normalize_min_max(values, is_inverse)


def _normalize_min_max(values: list[float], is_inverse: bool) -> list[float]:
    min_val = min(values)
    max_val = max(values)
    range_val = max_val - min_val

    if range_val == 0:
        return [50.0] * len(values)

    normalized = [(v - min_val) / range_val * 100 for v in values]
    if is_inverse:
        normalized = [100 - v for v in normalized]
    return normalized


def _normalize_z_score(values: list[float], is_inverse: bool) -> list[float]:
    n = len(values)
    mean = sum(values) / n
    variance = sum((v - mean) ** 2 for v in values) / n
    std = math.sqrt(variance) if variance > 0 else 1.0

    z_scores = [(v - mean) / std for v in values]
    # Convert z-scores to 0-100 scale using CDF approximation
    normalized = [_z_to_percentile(z) for z in z_scores]
    if is_inverse:
        normalized = [100 - v for v in normalized]
    return normalized


def _normalize_percentile(values: list[float], is_inverse: bool) -> list[float]:
    n = len(values)
    sorted_indices = sorted(range(n), key=lambda i: values[i])
    ranks = [0.0] * n
    for rank, idx in enumerate(sorted_indices):
        ranks[idx] = (rank / (n - 1)) * 100 if n > 1 else 50.0

    if is_inverse:
        ranks = [100 - r for r in ranks]
    return ranks


def _z_to_percentile(z: float) -> float:
    """Approximate CDF for standard normal, scaled to 0-100."""
    # Abramowitz and Stegun approximation
    if z < -4:
        return 0.0
    if z > 4:
        return 100.0
    t = 1 / (1 + 0.2316419 * abs(z))
    d = 0.3989422804014327  # 1/sqrt(2*pi)
    p = d * math.exp(-z * z / 2)
    poly = t * (0.319381530 + t * (-0.356563782 + t * (1.781477937 + t * (-1.821255978 + t * 1.330274429))))
    cdf = 1 - p * poly if z >= 0 else p * poly
    return cdf * 100


def calculate_category_score(
    indicators: list[IndicatorData],
    normalized_values: dict[str, float],
) -> float:
    """Calculate weighted average score for a single category (0-100)."""
    total_weight = sum(ind.weight for ind in indicators)
    if total_weight == 0:
        return 0.0

    weighted_sum = sum(
        normalized_values.get(ind.indicator_id, 0.0) * ind.weight
        for ind in indicators
    )
    return weighted_sum / total_weight


def calculate_composite_score(
    category_scores: dict[str, float],
    category_weights: list[CategoryWeight],
) -> float:
    """Calculate composite SVI score from category scores (0-100)."""
    total_weight = sum(cw.weight for cw in category_weights)
    if total_weight == 0:
        return 0.0

    weighted_sum = sum(
        category_scores.get(cw.name, 0.0) * cw.weight
        for cw in category_weights
    )
    return weighted_sum / total_weight


def assign_grade(score: float) -> str:
    """Assign KPMG grade based on composite score."""
    return KPMGGrade.from_score(score).value


def calculate_risk_index(
    vulnerability_index: float,
    resources_score: float,
    pressure_score: float,
    funding_score: float,
) -> float:
    """Calculate Risk Index = 0.4*VI + 0.2*Resources + 0.2*Pressure + 0.2*Funding."""
    return (
        0.4 * vulnerability_index
        + 0.2 * resources_score
        + 0.2 * pressure_score
        + 0.2 * funding_score
    )


def calculate_region_scores(
    region_id: str,
    indicators_by_category: dict[str, list[IndicatorData]],
    normalized_values: dict[str, float],
    category_weights: list[CategoryWeight],
) -> RegionScore:
    """Calculate all scores for a single region."""
    category_scores: dict[str, float] = {}

    for category_name, indicators in indicators_by_category.items():
        category_scores[category_name] = calculate_category_score(
            indicators, normalized_values
        )

    composite = calculate_composite_score(category_scores, category_weights)
    grade = assign_grade(composite)

    return RegionScore(
        region_id=region_id,
        composite_score=round(composite, 2),
        grade=grade,
        category_scores={k: round(v, 2) for k, v in category_scores.items()},
    )
